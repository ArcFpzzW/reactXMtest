{"ast":null,"code":"/**\r\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\r\n * License: MIT - http://mrgnrdrck.mit-license.org\r\n *\r\n * https://github.com/mroderick/PubSubJS\r\n */\n(function (root, factory) {\n  'use strict';\n\n  var PubSub = {};\n  root.PubSub = PubSub;\n  var define = root.define;\n  factory(PubSub); // AMD support\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return PubSub;\n    }); // CommonJS and Node.js module support\n  } else if (typeof exports === 'object') {\n    if (module !== undefined && module.exports) {\n      exports = module.exports = PubSub; // Node.js specific `module.exports`\n    }\n\n    exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\n\n    module.exports = exports = PubSub; // CommonJS\n  }\n})(typeof window === 'object' && window || this, function (PubSub) {\n  'use strict';\n\n  var messages = {},\n      lastUid = -1;\n\n  function hasKeys(obj) {\n    var key;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns a function that throws the passed exception, for use as argument for setTimeout\r\n   * @alias throwException\r\n   * @function\r\n   * @param { Object } ex An Error object\r\n   */\n\n\n  function throwException(ex) {\n    return function reThrowException() {\n      throw ex;\n    };\n  }\n\n  function callSubscriberWithDelayedExceptions(subscriber, message, data) {\n    try {\n      subscriber(message, data);\n    } catch (ex) {\n      setTimeout(throwException(ex), 0);\n    }\n  }\n\n  function callSubscriberWithImmediateExceptions(subscriber, message, data) {\n    subscriber(message, data);\n  }\n\n  function deliverMessage(originalMessage, matchedMessage, data, immediateExceptions) {\n    var subscribers = messages[matchedMessage],\n        callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\n        s;\n\n    if (!messages.hasOwnProperty(matchedMessage)) {\n      return;\n    }\n\n    for (s in subscribers) {\n      if (subscribers.hasOwnProperty(s)) {\n        callSubscriber(subscribers[s], originalMessage, data);\n      }\n    }\n  }\n\n  function createDeliveryFunction(message, data, immediateExceptions) {\n    return function deliverNamespaced() {\n      var topic = String(message),\n          position = topic.lastIndexOf('.'); // deliver the message as it is now\n\n      deliverMessage(message, message, data, immediateExceptions); // trim the hierarchy and deliver message to each level\n\n      while (position !== -1) {\n        topic = topic.substr(0, position);\n        position = topic.lastIndexOf('.');\n        deliverMessage(message, topic, data, immediateExceptions);\n      }\n    };\n  }\n\n  function messageHasSubscribers(message) {\n    var topic = String(message),\n        found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic])),\n        position = topic.lastIndexOf('.');\n\n    while (!found && position !== -1) {\n      topic = topic.substr(0, position);\n      position = topic.lastIndexOf('.');\n      found = Boolean(messages.hasOwnProperty(topic) && hasKeys(messages[topic]));\n    }\n\n    return found;\n  }\n\n  function publish(message, data, sync, immediateExceptions) {\n    message = typeof message === 'symbol' ? message.toString() : message;\n    var deliver = createDeliveryFunction(message, data, immediateExceptions),\n        hasSubscribers = messageHasSubscribers(message);\n\n    if (!hasSubscribers) {\n      return false;\n    }\n\n    if (sync === true) {\n      deliver();\n    } else {\n      setTimeout(deliver, 0);\n    }\n\n    return true;\n  }\n  /**\r\n   * Publishes the message, passing the data to it's subscribers\r\n   * @function\r\n   * @alias publish\r\n   * @param { String } message The message to publish\r\n   * @param {} data The data to pass to subscribers\r\n   * @return { Boolean }\r\n   */\n\n\n  PubSub.publish = function (message, data) {\n    return publish(message, data, false, PubSub.immediateExceptions);\n  };\n  /**\r\n   * Publishes the the message synchronously, passing the data to it's subscribers\r\n   * @function\r\n   * @alias publishSync\r\n   * @param { String } message The message to publish\r\n   * @param {} data The data to pass to subscribers\r\n   * @return { Boolean }\r\n   */\n\n\n  PubSub.publishSync = function (message, data) {\n    return publish(message, data, true, PubSub.immediateExceptions);\n  };\n  /**\r\n   * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\r\n   * @function\r\n   * @alias subscribe\r\n   * @param { String } message The message to subscribe to\r\n   * @param { Function } func The function to call when a new message is published\r\n   * @return { String }\r\n   */\n\n\n  PubSub.subscribe = function (message, func) {\n    if (typeof func !== 'function') {\n      return false;\n    }\n\n    message = typeof message === 'symbol' ? message.toString() : message; // message is not registered yet\n\n    if (!messages.hasOwnProperty(message)) {\n      messages[message] = {};\n    } // forcing token as String, to allow for future expansions without breaking usage\n    // and allow for easy use as key names for the 'messages' object\n\n\n    var token = 'uid_' + String(++lastUid);\n    messages[message][token] = func; // return token for unsubscribing\n\n    return token;\n  };\n  /**\r\n   * Subscribes the passed function to the passed message once\r\n   * @function\r\n   * @alias subscribeOnce\r\n   * @param { String } message The message to subscribe to\r\n   * @param { Function } func The function to call when a new message is published\r\n   * @return { PubSub }\r\n   */\n\n\n  PubSub.subscribeOnce = function (message, func) {\n    var token = PubSub.subscribe(message, function () {\n      // before func apply, unsubscribe message\n      PubSub.unsubscribe(token);\n      func.apply(this, arguments);\n    });\n    return PubSub;\n  };\n  /**\r\n   * Clears all subscriptions\r\n   * @function\r\n   * @public\r\n   * @alias clearAllSubscriptions\r\n   */\n\n\n  PubSub.clearAllSubscriptions = function clearAllSubscriptions() {\n    messages = {};\n  };\n  /**\r\n   * Clear subscriptions by the topic\r\n   * @function\r\n   * @public\r\n   * @alias clearAllSubscriptions\r\n   */\n\n\n  PubSub.clearSubscriptions = function clearSubscriptions(topic) {\n    var m;\n\n    for (m in messages) {\n      if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {\n        delete messages[m];\n      }\n    }\n  };\n  /**\r\n   * Removes subscriptions\r\n   *\r\n   * - When passed a token, removes a specific subscription.\r\n   *\r\n  * - When passed a function, removes all subscriptions for that function\r\n   *\r\n  * - When passed a topic, removes all subscriptions for that topic (hierarchy)\r\n   * @function\r\n   * @public\r\n   * @alias subscribeOnce\r\n   * @param { String | Function } value A token, function or topic to unsubscribe from\r\n   * @example // Unsubscribing with a token\r\n   * var token = PubSub.subscribe('mytopic', myFunc);\r\n   * PubSub.unsubscribe(token);\r\n   * @example // Unsubscribing with a function\r\n   * PubSub.unsubscribe(myFunc);\r\n   * @example // Unsubscribing from a topic\r\n   * PubSub.unsubscribe('mytopic');\r\n   */\n\n\n  PubSub.unsubscribe = function (value) {\n    var descendantTopicExists = function (topic) {\n      var m;\n\n      for (m in messages) {\n        if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0) {\n          // a descendant of the topic exists:\n          return true;\n        }\n      }\n\n      return false;\n    },\n        isTopic = typeof value === 'string' && (messages.hasOwnProperty(value) || descendantTopicExists(value)),\n        isToken = !isTopic && typeof value === 'string',\n        isFunction = typeof value === 'function',\n        result = false,\n        m,\n        message,\n        t;\n\n    if (isTopic) {\n      PubSub.clearSubscriptions(value);\n      return;\n    }\n\n    for (m in messages) {\n      if (messages.hasOwnProperty(m)) {\n        message = messages[m];\n\n        if (isToken && message[value]) {\n          delete message[value];\n          result = value; // tokens are unique, so we can just stop here\n\n          break;\n        }\n\n        if (isFunction) {\n          for (t in message) {\n            if (message.hasOwnProperty(t) && message[t] === value) {\n              delete message[t];\n              result = true;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n});","map":null,"metadata":{},"sourceType":"script"}